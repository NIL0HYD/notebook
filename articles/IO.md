# I/O

-[系统级I/O与标准I/O--“深入理解计算机系统”](http://blog.163.com/zhaohai_1988/blog/static/2095100852012721114648489/)

-[26、深入理解计算机系统笔记，系统级I/O](http://www.cnblogs.com/mydomain/archive/2011/07/03/2096950.html)

-[深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/)

>一个unix文件就是一个m字节的序列（b0b1b2...bm-1）。
>在UNIX系统中有一个说法，一切皆文件。所有的IO设备，如网络，磁盘，终端，都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。
>对于内核而言，文件文件和二进制文件毫无区别。

>打开文件 打开文件操作完成以后才能对文件进行一些列的操作，打开完成过以后会返回一个文件描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。

>内核用三种相关的数据结构来表示打开的文件。
1）描述符表：它的表项由进程打开的文件描述符来索引的。
2）文件表：打开文件的集合是一张文件表来表示的，所有的进程共享这张表。
3）v-node表：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大部分信息，如文件大小等。

>关闭文件 应用完成了对文件的访问之后，就通知内核关闭这个文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。进程终止，内核也会关闭所有打开的文件并释放他们的存储器资源。

>标准IO库将一个打开的文件模型化为一个流，对于程序员来说，一个流就是一个指向类型为FILE结构的一个指针。每个ANSI C程序开始都有三个打开的流stdin,stdout,stderr，分别对应于标准输入、输出、错误。
>类型为FILE的流是对文件描述符和流缓冲区的抽象。
>流的缓冲区的目的：就是使开销较高的Unix I/O系统调用的次数尽可能的减少。

>读和写文件
在系统I/O中读写文件用的系统函数为read()和write()函数来执行。
```
ssize_t read(int fd,void * buf,size_t n);  
ssize_t write(int fd,void *buf,size_t n);  
```
read函数从描述符为fd的当前文件位置拷贝最多n个字节到存储器位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。
而write函数从存储器位置buf拷贝至多n个字节到描述符fd的当前文件位置。返回值要么为-1要么为写入的字节数目。

>读取文件元数据
应用程序能够通过调用stat和fstat函数检索到关于文件的信息（有时也称为文件的元数据）
```
int stat(const char *filename,struct stat *buf);  
int fstat(int fd,struct stat *buf);
```
若成功，返回0，若出错则为-1.stat以一个文件名为输入，并且填充buf结构体。fstat函数只不过是以文件描述符而不是文件名作为输入。

>每个网络应用都是基于客户端-服务器模型的。客户端-服务器模型中的基本操作是事务（transaction）（这里的事务与数据库中的事务有区别，没有数据库事务的特性，如原子性，这时原事务仅仅是客户端和服务器之间执行的一系列步骤）。认识到客户端和服务器是进程，而不是在本上下文中常被称为的机器或者主机。
>从unix内核的角度来看，套接字就是通信的端点；从unix程序的角度来看，套接字就是一个有相应描述符的打开文件。


## JAVA NIO 

>Channel 和 Selector，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。这里还有一个 Buffer 类，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。