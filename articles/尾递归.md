# 尾递归

-[浅谈尾递归](http://site.douban.com/196781/widget/notes/12161495/note/262014367/)

尾递归的概念就是函数返回之前的最后一个操作若是递归调用，则该函数进行了尾递归。

第二个问题，编译器是怎样优化尾递归的？
我们知道递归调用是通过栈来实现的，每调用一次函数，系统都将函数当前的变量、返回地址等信息保存为一个栈帧压入到栈中，那么一旦要处理的运算很大或者数据很多，有可能会导致很多函数调用或者很大的栈帧，这样不断的压栈，很容易导致栈的溢出。

我们回过头看一下尾递归的特性，函数在递归调用之前已经把所有的计算任务已经完毕了，他只要把得到的结果全交给子函数就可以了，无需保存什么，子函数其实可以不需要再去创建一个栈帧，直接把就着当前栈帧，把原先的数据覆盖即可。相对的，如果是普通的递归，函数在递归调用之前并没有完成全部计算，还需要调用递归函数完成后才能完成运算任务，比如return n * fact(n - 1);这句话，这个fact(n)在算完fact（n-1）之后才能得到n * fact(n - 1)的运算结果然后才能返回。

综上所述，编译器对尾递归的优化实际上就是当他发现你丫在做尾递归的时候，就不会去不断创建新的栈帧，而是就着当前的栈帧不断的去覆盖，一来防止栈溢出，二来节省了调用函数时创建栈帧的开销，用《算法精解》里面的原话就是：“When a compiler detects a call that is tail recursive, it overwrites the current activation record instead of pushing a new one onto the stack.”