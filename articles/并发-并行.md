# 并发 & 并行

>并发就是一心二用(多用)，比如你一边听老师讲课，一边低头看课桌下韩寒的小说。这两件事你在同时做，而且这两件事并不一定需要相关。而并行就是兵分几路干同一个事情。比如别人看小说只能一行一行的看，而你能一目十行，这就是并行。

并发，就是（多worker）同时干不同的事。
并行，就是（多worker）同时干相同的事。

-[并发(Concurrency)和并行(Parallelism)的区别](http://www.aqee.net/defining-concurrency-and-parallelism/)
-[并发不是并行](http://www.aqee.net/docs/Concurrency-is-not-Parallelism/#landing-slide)

## 概念

1. 内存模型

内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。

在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。

【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了final或synchronized明确请求了某些可见性的保证。

参考：-[java内存模型](http://baike.baidu.com/view/8657411.htm)

2. 竞态条件
　　竞态条件是由和事件时间相关的意料之外的依赖所导致的反常行为。 换句话说，一个程序员不正确的假设一个特殊的事件总是在另一个事件之前发生。

**竞态条件 & 临界区**

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。

3. 同步机制

在并发程序设计中，各进程对公共变量的访问必须加以约制，这种约制称为同步。进程的同步是通过同步机制实现的。

4. 线程happens before关系

新的内存模型语义在内存操作（读取字段，写入字段，锁，解锁）以及其他线程的操作（start 和 join）中创建了一个部分排序，在这些操作中，一些操作被称为happen before其他操作。当一个操作在另外一个操作之前发生，第一个操作保证能够排到前面并且对第二个操作可见。这些排序的规则如下：

- 线程中的每个操作happens before该线程中在程序顺序上后续的每个操作。
- 解锁一个监视器的操作happens before随后对相同监视器进行锁的操作。
- 对volatile字段的写操作happens before后续对相同volatile字段的读取操作。
- 线程上调用start()方法happens before这个线程启动后的任何操作。
- 一个线程中所有的操作都happens before从这个线程join()方法成功返回的任何其他线程。（注意思是其他线程等待一个线程的jion()方法完成，那么，这个线程中的所有操作happens before其他线程中的所有操作）

这意味着：任何内存操作，这个内存操作在退出一个同步块前对一个线程是可见的，对任何线程在它进入一个被相同的监视器保护的同步块后都是可见的，因为所有内存操作happens before释放监视器以及释放监视器happens before获取监视器。

5. 线程控制逃逸规则

线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。

>如果一个资源的创建，使用，销毁都在同一个线程内完成，
且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。

6. synchronized

- 实例方法
	Java实例方法同步是同步在**拥有该方法的实例对象上**。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。

- 静态方法
	静态方法的同步是指同步在**该方法所在的类对象上**。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。
	对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。

- 实例方法中的同步块
	注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。

- 静态方法中的同步块

7. 线程通信

- 通过共享对象通信
- 忙等待
- wait(),notify()和notifyAll()
- 丢失的信号
- 假唤醒
- 多线程等待相同信号
- 不要对常量字符串或全局对象调用wait()

8. 管程 (英语：Monitors，也称为监视器) 

是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。

9. 可重入

如果一个线程持有某个管程对象上的锁，那么它就有权访问所有在该管程对象上同步的块。这就叫可重入。若线程已经持有锁，那么它就可以重复访问所有使用该锁的代码块。

当一个线程重新获取锁，读写锁或其他不可重入的同步器时，就可能发生重入锁死。可重入的意思是线程可以重复获得它已经持有的锁。Java的synchronized块是可重入的。

10. 阻塞队列

阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来